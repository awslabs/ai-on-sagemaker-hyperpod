"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[5292],{6942:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>c,contentTitle:()=>a,default:()=>u,frontMatter:()=>i,metadata:()=>o,toc:()=>l});const o=JSON.parse('{"id":"Tips/Slurm/enable-cgroups","title":"Configure Cgroups for Slurm","description":"Cgroups is a Linux kernel feature that limits, accounts for, and isolates the resource usage (CPU, memory, disk I/O, etc.) of a collection of processes. In traditional environments, Cgroups allow system administrators to allocate resources such as CPU time, system memory, disk bandwidth, etc., among user-defined groups of tasks (processes) running on a system. We can configure Slurm to use Cgroups to constrain resources at the Slurm job and task level. A popular usecase for implementing Cgroups with Slurm is to use Process tracking proctrac/cgroup to isolate processes to a slurm job, thus ensuring all processes created by the job are contained within a cgroup, which helps in monitoring and controlling the resource usage by the job. It also helps in cleaning up processes after the job ends, ensuring that there are no \\"zombie\\" processes left running on the system.","source":"@site/docs/08-Tips/Slurm/16-enable-cgroups.md","sourceDirName":"08-Tips/Slurm","slug":"/Tips/Slurm/enable-cgroups","permalink":"/ai-on-sagemaker-hyperpod/docs/Tips/Slurm/enable-cgroups","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":16,"frontMatter":{"title":"Configure Cgroups for Slurm","weight":56},"sidebar":"tutorialSidebar","previous":{"title":"Heterogenous Cluster","permalink":"/ai-on-sagemaker-hyperpod/docs/Tips/Slurm/heterogenous-cluster"},"next":{"title":"Enable Slurm epilog Script","permalink":"/ai-on-sagemaker-hyperpod/docs/Tips/Slurm/slurm-epilogue"}}');var t=n(4848),r=n(8453);const i={title:"Configure Cgroups for Slurm",weight:56},a=void 0,c={},l=[{value:"Steps to enable c-groups:",id:"steps-to-enable-c-groups",level:3},{value:"1. Modify `slurm.conf: note you might need to remove existing mention of these from slurm.conf",id:"1-modify-slurmconf-note-you-might-need-to-remove-existing-mention-of-these-from-slurmconf",level:5},{value:"2. Create a new file <code>/opt/slurm/etc/cgroup.conf</code> and configure your cgroup options:",id:"2-create-a-new-file-optslurmetccgroupconf-and-configure-your-cgroup-options",level:5},{value:"3.Restart slurmctld and reconfigure to enable the configuration changes:",id:"3restart-slurmctld-and-reconfigure-to-enable-the-configuration-changes",level:5},{value:"Validation Tests",id:"validation-tests",level:5}];function h(e){const s={a:"a",code:"code",em:"em",h3:"h3",h5:"h5",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.a,{href:"https://en.wikipedia.org/wiki/Cgroups",children:"Cgroups"})," is a Linux kernel feature that limits, accounts for, and isolates the resource usage (CPU, memory, disk I/O, etc.) of a collection of processes. In traditional environments, Cgroups allow system administrators to allocate resources such as CPU time, system memory, disk bandwidth, etc., among user-defined groups of tasks (processes) running on a system. We can ",(0,t.jsx)(s.a,{href:"https://slurm.schedmd.com/cgroups.html",children:"configure Slurm to use Cgroups"})," to constrain resources at the Slurm job and task level. A popular usecase for implementing Cgroups with Slurm is to use Process tracking ",(0,t.jsx)(s.code,{children:"proctrac/cgroup"}),' to isolate processes to a slurm job, thus ensuring all processes created by the job are contained within a cgroup, which helps in monitoring and controlling the resource usage by the job. It also helps in cleaning up processes after the job ends, ensuring that there are no "zombie" processes left running on the system.']}),"\n",(0,t.jsx)(s.h3,{id:"steps-to-enable-c-groups",children:"Steps to enable c-groups:"}),"\n",(0,t.jsx)(s.p,{children:(0,t.jsxs)(s.em,{children:["Execute the following example steps on the ",(0,t.jsx)(s.strong,{children:"Controller Node"})," of your cluster"]})}),"\n",(0,t.jsx)(s.h5,{id:"1-modify-slurmconf-note-you-might-need-to-remove-existing-mention-of-these-from-slurmconf",children:"1. Modify `slurm.conf: note you might need to remove existing mention of these from slurm.conf"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-bash",children:"sudo vim /opt/slurm/etc/slurm.conf\n"})}),"\n",(0,t.jsx)(s.p,{children:"Add the following lines:"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-bash",children:"# Cgroup settings\nProctrackType=proctrack/cgroup\nTaskPlugin=task/cgroup,task/affinity\nPrologFlags=Contain\n\n# SCHEDULING\nSchedulerType=sched/backfill\nSelectType=select/cons_tres\nSelectTypeParameters=CR_Core_Memory\n"})}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.code,{children:"ProctrackType=proctrack/cgroup"}),": This setting tells Slurm to use Linux Control Groups (cgroups) to track and manage the processes started by a Slurm job. This ensures that all processes created by the job are contained within a cgroup."]}),"\n"]}),"\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.code,{children:"TaskPlugin=task/cgroup,task/affinity"}),": the ",(0,t.jsx)(s.code,{children:"task/cgroup"})," plugin is the main plugin for enabling cgroup support in Slurm. It integrates with the Linux cgroups subsystem to manage and limit resources such as CPU, memory, and I/O for jobs and job steps. It also allows Slurm to create, modify, and delete cgroups dynamically as jobs are scheduled, executed, and completed. You can read more about the ",(0,t.jsx)(s.code,{children:"task/Cgroup"})," plugin in the ",(0,t.jsx)(s.a,{href:"https://slurm.schedmd.com/cgroups.html#task",children:"Link to SchedMD Documentation"}),".The ",(0,t.jsx)(s.code,{children:"task/afinity"})," plugin handles CPU affinity for tasks, meaning it binds tasks to specific CPUs. This can improve performance by reducing context switching and cache misses, and it can ensure that tasks run on the CPUs allocated to them, promoting better resource utilization and isolation."]}),"\n"]}),"\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.code,{children:"PrologFlags=Contain"}),":"]}),"\n"]}),"\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.code,{children:"SchedulerType=sched/backfill"}),": Backfill is a scheduling technique used to optimize the utilization of resources. The backfill scheduler scans the queue of pending jobs and identifies jobs that can be started and completed without delaying the start of any higher-priority jobs. This helps to maximize resource utilization by filling in gaps in the schedule with smaller or shorter jobs."]}),"\n"]}),"\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.code,{children:"SelectType=select/cons_tres"})," plugin is available to manage resources on a much more fine-grained basis than exclusive node allocation. This allows for the use of Memory containment on the nodes Read more ",(0,t.jsx)(s.a,{href:"https://slurm.schedmd.com/cons_tres.html",children:"here"})]}),"\n"]}),"\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.code,{children:"SelectTypeParameters=CR_Core_Memory"}),": ensures that memory allocation is directly tied to core allocation, leading to a more balanced and efficient use of resources on the cluster."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(s.h5,{id:"2-create-a-new-file-optslurmetccgroupconf-and-configure-your-cgroup-options",children:["2. Create a new file ",(0,t.jsx)(s.code,{children:"/opt/slurm/etc/cgroup.conf"})," and configure your cgroup options:"]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-bash",children:"CgroupPlugin=autodetect\nConstrainDevices=yes\nConstrainRAMSpace=yes\nConstrainSwapSpace=yes\nSignalChildrenProcesses=yes\nMaxRAMPercent=50\n"})}),"\n",(0,t.jsx)(s.p,{children:"With this configuration, Slurm will create a cgroup hierarchy for each job and constrain the processes to the assigned resources, including GPUs. User processes will not be able to escape the cgroup and continue consuming resources after the job completes. For more information, see the below linked documentation:"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.code,{children:"CgroupPlugin=autodetect"})," If configured will try to determine which cgroup version (v1 or v2) the system is providing. This is a recomended setting from Schedmd. ",(0,t.jsx)(s.a,{href:"https://slurm.schedmd.com/cgroup.conf.html#SECTION_DESCRIPTION:~:text=sys/fs/cgroup.-,CgroupPlugin,-%3D%3Ccgroup/v1",children:"Link to SchedMD Documentation"}),"."]}),"\n"]}),"\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.code,{children:"ConstrainDevices=yes"}),' If configured to "yes" then constrain the job\'s allowed devices based on GRES allocated resources. It uses the devices subsystem for that. The default value is "no". ',(0,t.jsx)(s.a,{href:"https://slurm.schedmd.com/cgroup.conf.html#OPT_ConstrainDevices",children:"Link to SchedMD Documentation"}),"."]}),"\n"]}),"\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.code,{children:"ConstrainRAMSpace=yes"}),' If configured to "yes" then constrain the job\'s RAM usage by setting the memory soft limit to the allocated memory and the hard limit to the allocated memory * AllowedRAMSpace. The default value is "no", in which case the job\'s RAM limit will be set to its swap space limit if ConstrainSwapSpace is set to "yes". CR_*_Memory must be set in slurm.conf for this parameter to take any effect. Also see AllowedSwapSpace, AllowedRAMSpace and ConstrainSwapSpace. ',(0,t.jsx)(s.strong,{children:"NOTE:"}),"  When using ConstrainRAMSpace, if the combined memory used by all processes in a step is greater than the limit, then the kernel will trigger an OOM event, killing one or more of the processes in the step. The step state will be marked as OOM, but the step itself will keep running and other processes in the step may continue to run as well. This differs from the behavior of OverMemoryKill, where the whole step will be killed/cancelled. ",(0,t.jsx)(s.a,{href:"https://slurm.schedmd.com/cgroup.conf.html#OPT_ConstrainRAMSpace",children:"Link to SchedMD Documentation"}),"."]}),"\n"]}),"\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.code,{children:"ConstrainSwapSpace=yes"}),' If configured to "yes" then constrain the job\'s swap space usage. The default value is "no". Note that when set to "yes" and ConstrainRAMSpace is set to "no", AllowedRAMSpace is automatically set to 100% in order to limit the RAM+Swap amount to 100% of job\'s requirement plus the percent of allowed swap space. This amount is thus set to both RAM and RAM+Swap limits. This means that in that particular case, ConstrainRAMSpace is automatically enabled with the same limit as the one used to constrain swap space. CR_*_Memory must be set in slurm.conf for this parameter to take any effect. Also see AllowedSwapSpace.',(0,t.jsx)(s.a,{href:"https://slurm.schedmd.com/cgroup.conf.html#OPT_ConstrainSwapSpace",children:"Link to SchedMD Documentation"}),"."]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(s.h5,{id:"3restart-slurmctld-and-reconfigure-to-enable-the-configuration-changes",children:"3.Restart slurmctld and reconfigure to enable the configuration changes:"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-bash",children:"sudo systemctl restart slurmctld\nsudo scontrol reconfigure\n"})}),"\n",(0,t.jsx)(s.h5,{id:"validation-tests",children:"Validation Tests"}),"\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.strong,{children:"1."})," In the following test, we will start a sleep process and exit leaving it in background. Use the below bash script to run a job which runs a sleep command (600 seconds) and exits. We can test this before and after configuring the cgroup and notice the process gets killed with cgroups configured."]}),"\n",(0,t.jsxs)(s.p,{children:["Create a file called ",(0,t.jsx)(s.code,{children:"test.sh"})," which contains:"]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-bash",children:'#! /bin/bash\n# SBATCH \u2014nodes 1\n\n\necho "1"\necho $(sleep 600 &) &\necho "2"\n'})}),"\n",(0,t.jsx)(s.p,{children:"Now lets run the script and check if the process is killed."}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-bash",children:"sbatch test.sh \n\n# check if the job completed\n\nscontrol show job <job_id> \n\n# Now we should not be able to see the process on the node with srun when using cgroup\n\nsrun -N 1 ps aux | head -n 1; ps aux | grep sleep\n"})}),"\n",(0,t.jsxs)(s.p,{children:["Note without c-groups enabled, you will be able to find the sleep process continuing to run after the slurm job has canceled (for 600 seconds as defined in the script).  If the ",(0,t.jsx)(s.code,{children:"ProctrackType=proctrack/cgroup"})," is correctly configured, you will not see the sleep process when sshing onto the node, because it was killed when the job ended."]}),"\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.strong,{children:"2."})," (optional) Start a tmux session within a srun session"]}),"\n",(0,t.jsxs)(s.p,{children:["The following demonstrates a situation of a process that will not be killed by cgroups. On HyperPod, although not recommended, users may launch a job or process outside of Slurm, one common scenario is ",(0,t.jsx)(s.code,{children:"tmux"}),". Tmux has its own daemon to manage sessions, so the session that is created when you use ",(0,t.jsx)(s.code,{children:"tmux"})," belongs to that tmux manager and not slurm. As a result any process started by tmux session will not be cleaned up by cgroups."]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-bash",children:"srun -t 4:00:00 --pty bash\ntmux # start tmux sessions\nwhile [ true ]; do echo hi; sleep 1 ; done\n# detach from tmux session\n# leave the node and end the job\n"})}),"\n",(0,t.jsxs)(s.ol,{start:"3",children:["\n",(0,t.jsx)(s.li,{children:"Memory Test to check enforcement of memory limits"}),"\n"]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-bash",children:"git clone https://github.com/josenk/alloc_mem\ncd alloc_mem\nmake 64bit\nsrun -N 1 ./alloc_mem -r -l 2000000 8000\n"})}),"\n",(0,t.jsx)(s.p,{children:"The above job will allocate 2 TiB of Memory in 8 GB chunks. it should take ~5 min to OOM on a p5.48xlarge.\nwhile the job is running, open up a second terminal, ssh into the node which the memory test job is running on, and check free memory:"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-bash",children:"### see which node is allocated to the jon\nsqueue\n### ssh into that node and check for memory utilization\nssh <ipv-4-for-job>\nfree -m\n"})}),"\n",(0,t.jsx)(s.p,{children:"When memory hits the threshold, you will see used memory cap out, and the srun job will fail with:"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{children:"slurmstepd: error: Detected 1 oom_kill event in StepId=29.0. Some of the\nstep tasks have been OOM Killed.\nsrun: error: ip-10-1-10-5: task 0: Out Of Memory\n"})}),"\n",(0,t.jsx)(s.p,{children:"Congratulations, you have successfully setup and tested memory enforcement and process tracking via c-groups."})]})}function u(e={}){const{wrapper:s}={...(0,r.R)(),...e.components};return s?(0,t.jsx)(s,{...e,children:(0,t.jsx)(h,{...e})}):h(e)}},8453:(e,s,n)=>{n.d(s,{R:()=>i,x:()=>a});var o=n(6540);const t={},r=o.createContext(t);function i(e){const s=o.useContext(r);return o.useMemo(function(){return"function"==typeof e?e(s):{...s,...e}},[s,e])}function a(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:i(e.components),o.createElement(r.Provider,{value:s},e.children)}}}]);