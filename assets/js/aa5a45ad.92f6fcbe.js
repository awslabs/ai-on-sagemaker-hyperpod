"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[2949],{5251:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"getting-started/orchestrated-by-eks/Set up your shared file system","title":"Set up your shared file system","description":"Install the Amazon FSx for Lustre CSI Driver","source":"@site/docs/00-getting-started/orchestrated-by-eks/Set up your shared file system.md","sourceDirName":"00-getting-started/orchestrated-by-eks","slug":"/getting-started/orchestrated-by-eks/Set up your shared file system","permalink":"/docs/getting-started/orchestrated-by-eks/Set up your shared file system","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":5,"frontMatter":{"title":"Set up your shared file system","sidebar_position":5},"sidebar":"tutorialSidebar","previous":{"title":"Additional Information","permalink":"/docs/getting-started/orchestrated-by-eks/additional-information"},"next":{"title":"Adding a Data Repository Association","permalink":"/docs/getting-started/orchestrated-by-eks/Adding a Data Repository Assocation"}}');var i=n(4848),r=n(8453);const a={title:"Set up your shared file system",sidebar_position:5},o=void 0,l={},c=[{value:"Install the Amazon FSx for Lustre CSI Driver",id:"install-the-amazon-fsx-for-lustre-csi-driver",level:4},{value:"Dynamic Provisioning",id:"dynamic-provisioning",level:4},{value:"Static Provisioning (Optional)",id:"static-provisioning-optional",level:4},{value:"To use an existing FSxL File system with the CSI driver follow the below steps",id:"to-use-an-existing-fsxl-file-system-with-the-csi-driver-follow-the-below-steps",level:4},{value:"Mount the volume to container",id:"mount-the-volume-to-container",level:4}];function d(e){const s={a:"a",blockquote:"blockquote",code:"code",div:"div",h4:"h4",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components},{Details:n}=s;return n||function(e,s){throw new Error("Expected "+(s?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Details",!0),(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(s.h4,{id:"install-the-amazon-fsx-for-lustre-csi-driver",children:"Install the Amazon FSx for Lustre CSI Driver"}),"\n",(0,i.jsxs)(s.p,{children:["The ",(0,i.jsx)(s.a,{href:"https://github.com/kubernetes-sigs/aws-fsx-csi-driver",children:"Amazon FSx for Lustre Container Storage Interface (CSI) driver"})," uses ",(0,i.jsx)(s.a,{href:"https://docs.aws.amazon.com/eks/latest/userguide/iam-roles-for-service-accounts.html",children:"IAM roles for service accounts (IRSA)"})," to authenticate AWS API calls. To use IRSA, an ",(0,i.jsx)(s.a,{href:"https://docs.aws.amazon.com/eks/latest/userguide/enable-iam-roles-for-service-accounts.html",children:"IAM OpenID Connect (OIDC) provider"})," needs to be associated with the OIDC issuer URL that comes provisioned your EKS cluster."]}),"\n",(0,i.jsxs)(s.blockquote,{children:["\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"Performance best practice:"}),"\nMake sure that your file system is located in the same Region and Availability Zone as your compute nodes. Accessing a file system in a different Region or Availability Zone will result in reduced I/O performance and increased network costs."]}),"\n"]}),"\n",(0,i.jsx)(s.p,{children:"Create an IAM OIDC identity provider for your cluster with the following command:"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-bash",children:"eksctl utils associate-iam-oidc-provider --cluster $EKS_CLUSTER_NAME --approve\n"})}),"\n",(0,i.jsx)(s.p,{children:"Create a service account with an IAM role mapped to it for use with the FSx for Lustre CSI driver:"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-bash",children:"eksctl create iamserviceaccount \\\n  --name fsx-csi-controller-sa \\\n  --namespace kube-system \\\n  --cluster $EKS_CLUSTER_NAME \\\n  --attach-policy-arn arn:aws:iam::aws:policy/AmazonFSxFullAccess \\\n  --approve \\\n  --role-name FSXLCSI-${EKS_CLUSTER_NAME}-${AWS_REGION} \\\n  --region $AWS_REGION\n"})}),"\n",(0,i.jsx)(s.p,{children:"Verify proper annotation of the service account with the IAM role ARN:"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-bash",children:"kubectl get sa fsx-csi-controller-sa -n kube-system -oyaml \n"})}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{children:'apiVersion: v1\nkind: ServiceAccount\nmetadata:\n  annotations:\n    eks.amazonaws.com/role-arn: arn:aws:iam::012345678910:role/FSXLCSI-sagemaker-hyperpod-eks-cluster-us-west-2\n  creationTimestamp: "2025-06-05T15:17:19Z"\n  labels:\n    app.kubernetes.io/managed-by: eksctl\n  name: fsx-csi-controller-sa\n  namespace: kube-system\n  resourceVersion: "43455"\n  uid: 514c9567-7021-469f-b700-6f55e3e9e864\n'})}),"\n",(0,i.jsx)(s.p,{children:"Deploy the FSx for Lustre CSI driver using Helm:"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-bash",children:"helm repo add aws-fsx-csi-driver https://kubernetes-sigs.github.io/aws-fsx-csi-driver\n\nhelm repo update\n\nhelm upgrade --install aws-fsx-csi-driver aws-fsx-csi-driver/aws-fsx-csi-driver\\\n  --namespace kube-system \\\n  --set controller.serviceAccount.create=false\n"})}),"\n",(0,i.jsx)(s.p,{children:"Verify instillation of the FSx for Lustre CSI driver:"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-bash",children:"kubectl get pods -n kube-system -l app.kubernetes.io/name=aws-fsx-csi-driver\n"})}),"\n",(0,i.jsx)(s.hr,{}),"\n",(0,i.jsxs)(s.p,{children:["The ",(0,i.jsx)(s.a,{href:"https://github.com/kubernetes-sigs/aws-fsx-csi-driver",children:"Amazon FSx for Lustre CSI driver"})," presents you with two options for provisioning a file system:"]}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"Dynamic Provisioning"}),": This option leverages Persistent Volume Claims (PVCs) in Kubernetes. You define a PVC with desired storage specifications. The CSI Driver automatically provisions the FSx file system for you based on the PVC request. This allows for easier scaling and eliminates the need to manually create file systems."]}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"Static Provisioning"}),": In this method, you manually create the FSx file system before using the CSI Driver. You'll need to configure details like subnet ID and security groups for the file system. Then, you can use the Driver to mount this pre-created file system within your container as a volume."]}),"\n",(0,i.jsx)(s.h4,{id:"dynamic-provisioning",children:"Dynamic Provisioning"}),"\n",(0,i.jsxs)(s.p,{children:["To dynamically provision an FSx for Lustre file system, start by creating a storage class that leverages the ",(0,i.jsx)(s.code,{children:"fsx.csi.aws.com"})," provisioner:"]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-bash",children:'cat <<EOF> storageclass.yaml\nkind: StorageClass\napiVersion: storage.k8s.io/v1\nmetadata:\n  name: fsx-sc\nprovisioner: fsx.csi.aws.com\nparameters:\n  subnetId: $PRIVATE_SUBNET_ID\n  securityGroupIds: $SECURITY_GROUP_ID\n  deploymentType: PERSISTENT_2\n  automaticBackupRetentionDays: "0"\n  copyTagsToBackups: "true"\n  perUnitStorageThroughput: "250"\n  dataCompressionType: "LZ4"\n  fileSystemTypeVersion: "2.15"\nmountOptions:\n  - flock\nEOF\n'})}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-bash",children:"kubectl apply -f storageclass.yaml\n"})}),"\n",(0,i.jsxs)(n,{children:[(0,i.jsx)("summary",{children:"Parameter Explanation"}),(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:["\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"privateSubnetId"})," - The subnet ID that the FSx for Lustre filesystem should be created inside. Using the ",(0,i.jsx)(s.code,{children:"$PRIVATE_SUBNET_ID"})," environment variable, we are referencing the same private subnet that was used for HyperPod cluster creation."]}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:["\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"securityGroupIds"})," - A list of security group IDs that should be attached to the filesystem. Using the ",(0,i.jsx)(s.code,{children:"$SECURITY_GROUP"})," environment variable, we are referencing the same security group that was use for HyperPod cluster creation."]}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:["\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"deploymentType"}),": ",(0,i.jsx)(s.code,{children:"PERSISTENT_2"})," is the latest generation of Persistent deployment type, and is best-suited for use cases that require longer-term storage, and have latency-sensitive workloads that require the highest levels of IOPS and throughput. For more information see ",(0,i.jsx)(s.a,{href:"https://docs.aws.amazon.com/fsx/latest/LustreGuide/using-fsx-lustre.html",children:"Deployment options for FSx for Lustre file systems"}),"."]}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:["\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"automaticBackupRetentionDays"}),": The number of days to retain automatic backups. Setting this value to 0 disables the creation of automatic backups. If you set this parameter to a non-zero value, you can also specify the preferred time to take daily backups using the dailyAutomaticBackupStartTime parameter."]}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:["\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"copyTagsToBackups"}),": If this value is true, all tags for the file system are copied to all automatic and user-initiated backups."]}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:["\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"perUnitStorageThroughput"}),": For ",(0,i.jsx)(s.code,{children:"PERSISTENT_2"})," deployments, you can specify the storage throughput in MBps per TiB of storage capacity."]}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:["\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"dataCompressionType"}),": FSx for Lustre supports data compression via the LZ4 algorithm, which is optimized to deliver high levels of compression without adversely impacting file system performance. For more information see ",(0,i.jsx)(s.a,{href:"https://docs.aws.amazon.com/fsx/latest/LustreGuide/data-compression.html",children:"Lustre data compression"}),"."]}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:["\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"fileSystemTypeVersion"}),": This sets the Lustre version for the FSx for Lustre file system that will be created."]}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:["\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"mountOptions"}),": A list of mount options for the file system. The ",(0,i.jsx)(s.code,{children:"flock"})," option mounts your file system with file lock enabled."]}),"\n"]}),"\n"]}),(0,i.jsxs)(s.p,{children:["You can find more information about storage class parameters in the ",(0,i.jsx)(s.a,{href:"https://github.com/kubernetes-sigs/aws-fsx-csi-driver/tree/master/examples/kubernetes/dynamic_provisioning#dynamic-provisioning-example",children:"aws-fsx-csi-driver GitHub repository"})]})]}),"\n",(0,i.jsxs)(s.p,{children:["Verify the ",(0,i.jsx)(s.code,{children:"fsx-sc"})," storage class was created:"]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-bash",children:"kubectl get sc fsx-sc -oyaml\n"})}),"\n",(0,i.jsxs)(s.p,{children:["Next, create a persistent volume claim (PVC) that uses the ",(0,i.jsx)(s.code,{children:"fsx-claim"})," storage claim:"]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-bash",children:"cat <<EOF> pvc.yaml\napiVersion: v1\nkind: PersistentVolumeClaim\nmetadata:\n  name: fsx-claim\n  namespace: default\nspec:\n  accessModes:\n    - ReadWriteMany\n  storageClassName: fsx-sc\n  resources:\n    requests:\n      storage: 1200Gi\nEOF\n"})}),"\n",(0,i.jsxs)(s.blockquote,{children:["\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"Note"}),"\nPVCs are namespaced Kubernetes resources, so be sure to change the namespace as needed before creation."]}),"\n"]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-bash",children:"kubectl apply -f pvc.yaml\n"})}),"\n",(0,i.jsx)(s.p,{children:"This PVC will kick off the dynamic provisioning of an FSx for Lustre file system based on the specifications provided in the storage class."}),"\n",(0,i.jsx)(s.p,{children:"View the status of the PVC:"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-bash",children:"kubectl describe pvc fsx-claim \n"})}),"\n",(0,i.jsxs)(s.p,{children:["Check to see if the PVC is in a ",(0,i.jsx)(s.code,{children:"Pending"})," or ",(0,i.jsx)(s.code,{children:"Bound"})," state:"]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-bash",children:" kubectl get pvc fsx-claim  -n default  -ojson \\\n | jq -r .status.phase\n"})}),"\n",(0,i.jsxs)(s.p,{children:["Ensure that the status is set to ",(0,i.jsx)(s.code,{children:"Bound"})," before deploying any pods that reference the persistent volume claim. The status may remain in a ",(0,i.jsx)(s.code,{children:"Pending"})," state ( ~10 mins) while the file system is being provisioned."]}),"\n",(0,i.jsx)(s.p,{children:"Retrieve the associated FSx for Lustre volume ID:"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-bash",children:"kubectl get pv $(kubectl get pvc fsx-claim  -n default -ojson \\\n | jq -r .spec.volumeName) -ojson \\\n | jq -r .spec.csi.volumeHandle\n"})}),"\n",(0,i.jsx)(s.h4,{id:"static-provisioning-optional",children:"Static Provisioning (Optional)"}),"\n",(0,i.jsx)(s.p,{children:"Alternatively, if you prefer to deploy a standalone FSx for Lustre file system using AWS CloudFormation, click the button below:"}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.div,{children:"Deploy the FSx for Lustre File System Stack"})}),"\n",(0,i.jsxs)(s.p,{children:["For the Security Group ID and Subnet ID in the network options, use the IDs available from the environment variables - ",(0,i.jsx)(s.code,{children:"$SECURITY_GROUP"}),", and ",(0,i.jsx)(s.code,{children:"$PRIVATE_SUBNET_ID"}),"."]}),"\n",(0,i.jsx)(s.h4,{id:"to-use-an-existing-fsxl-file-system-with-the-csi-driver-follow-the-below-steps",children:"To use an existing FSxL File system with the CSI driver follow the below steps"}),"\n",(0,i.jsxs)(s.blockquote,{children:["\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"Note:"}),"\nBefore using an existing file system with the CSI driver on your EKS HyperPod cluster, please ensure that your FSx file system is in the same subnet (and thus, same Availability Zone) as your HyperPod cluster nodes."]}),"\n",(0,i.jsxs)(s.p,{children:["You can check the subnet of your HyperPod nodes by checking the ",(0,i.jsx)(s.code,{children:"$PRIVATE_SUBNET_ID"})," environment variable set as part of this cluster creation process."]}),"\n",(0,i.jsx)(s.p,{children:"To check the subnet ID of your existing file system, run"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-bash",children:"# Replace fs-xxx with your file system id\naws fsx describe-file-systems --file-system-id fs-xxx --query 'FileSystems[0].SubnetIds[]' --output text\n"})}),"\n"]}),"\n",(0,i.jsxs)(s.blockquote,{children:["\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"Note:"}),"\nThe following YAMLs require variables that are not in our env_vars. To retrieve the variables, you can find them in your AWS console in ",(0,i.jsx)(s.code,{children:"FSx for Lustre"})," page, or you can run these commands:"]}),"\n",(0,i.jsx)(s.p,{children:"FSx For Lustre ID:"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-bash",children:"aws fsx describe-file-systems --region $AWS_REGION | jq -r '.FileSystems[0].FileSystemId'\n"})}),"\n",(0,i.jsx)(s.p,{children:"FSx DNS Name:"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-bash",children:"aws fsx describe-file-systems --region $AWS_REGION --file-system-id <fs-xxxx> --query 'FileSystems[0].DNSName' --output text\n"})}),"\n",(0,i.jsx)(s.p,{children:"FSx Mount Name:"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-bash",children:"aws fsx describe-file-systems --region $AWS_REGION --file-system-id <fs-xxxx> --query 'FileSystems[0].LustreConfiguration.MountName' --output text\n"})}),"\n"]}),"\n",(0,i.jsxs)(s.ol,{children:["\n",(0,i.jsx)(s.li,{children:"Create a StorageClass that references your existing FSx file system. Replace the fileSystemId, subnetId and securityGroupIDs in the yaml file accordingly."}),"\n"]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-bash",children:"cat <<EOF> storageclass.yaml\napiVersion: storage.k8s.io/v1\nkind: StorageClass\nmetadata:\n  name: fsx-sc\nprovisioner: fsx.csi.aws.com\nparameters:\n  fileSystemId: fs-xxxx # Replace with your FSx file system ID\n  subnetId: subnet-xxxx  # Replace with your subnet ID\n  securityGroupIds: $SECURITY_GROUP_ID  # Replace with your security group ID\nEOF\n\nkubectl apply -f storageclass.yaml\n"})}),"\n",(0,i.jsxs)(s.ol,{start:"2",children:["\n",(0,i.jsx)(s.li,{children:"Create a PersistentVolume (PV) that references your existing FSx volume. Replace the storage and volumeHandle parameters accordingly."}),"\n"]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-bash",children:"cat <<EOF> pv.yaml\napiVersion: v1\nkind: PersistentVolume\nmetadata:\n  name: fsx-pv\nspec:\n  capacity:\n    storage: 1200Gi  # Adjust based on your FSx volume size\n  volumeMode: Filesystem\n  accessModes:\n    - ReadWriteMany\n  persistentVolumeReclaimPolicy: Retain\n  storageClassName: fsx-sc\n  csi:\n    driver: fsx.csi.aws.com\n    volumeHandle: fs-xxxxx  # Replace with your FSx file system ID\n    volumeAttributes:\n      dnsname: fs-xxxxx.fsx.region.amazonaws.com  # Replace with your FSx file system DNS name\n      mountname: abc123  # Replace with your FSx file system mountname\nEOF\n\nkubectl apply -f pv.yaml\n"})}),"\n",(0,i.jsxs)(s.ol,{start:"3",children:["\n",(0,i.jsx)(s.li,{children:"Create a PersistentVolumeClaim (PVC) to use the existing FSx volume. Verify if the storage parameter value matches the PV size created above."}),"\n"]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-bash",children:"cat <<EOF> pvc.yaml\napiVersion: v1\nkind: PersistentVolumeClaim\nmetadata:\n  name: fsx-claim\nspec:\n  accessModes:\n    - ReadWriteMany\n  storageClassName: fsx-sc\n  resources:\n    requests:\n      storage: 1200Gi  # Should match the PV size\nEOF\n\nkubectl apply -f pvc.yaml\n"})}),"\n",(0,i.jsx)(s.h4,{id:"mount-the-volume-to-container",children:"Mount the volume to container"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-bash",children:'cat <<EOF> pod.yaml\napiVersion: v1\nkind: Pod\nmetadata:\n  name: fsx-app\nspec:\n  containers:\n  - name: app\n    image: ubuntu\n    command: ["/bin/sh"]\n    args: ["-c", "while true; do echo $(date -u) >> /data/out.txt; sleep 5; done"]\n    volumeMounts:\n    - name: persistent-storage\n      mountPath: /data\n  volumes:\n  - name: persistent-storage\n    persistentVolumeClaim:\n      claimName: fsx-claim\nEOF\n\nkubectl apply -f pod.yaml\n\n'})})]})}function h(e={}){const{wrapper:s}={...(0,r.R)(),...e.components};return s?(0,i.jsx)(s,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453:(e,s,n)=>{n.d(s,{R:()=>a,x:()=>o});var t=n(6540);const i={},r=t.createContext(i);function a(e){const s=t.useContext(r);return t.useMemo(function(){return"function"==typeof e?e(s):{...s,...e}},[s,e])}function o(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),t.createElement(r.Provider,{value:s},e.children)}}}]);